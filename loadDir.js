// Generated by CoffeeScript 1.6.2
(function() {
  var CoffeeScript, child, extension, fs, loadDir, trim_ext, _, _ref, _to_filename,
    __slice = [].slice;

  _ = require('underscore');

  fs = require('fs');

  child = require('child_process');

  CoffeeScript = require('coffee-script');

  _ref = require('./string_helper'), extension = _ref.extension, trim_ext = _ref.trim_ext;

  _to_filename = function(filename, ext) {
    return [filename, ext].join('.');
  };

  module.exports = loadDir = function(options) {
    var args, as_object, binary, black_list, callback, compile, destination, filenamesOnly, freshen, on_change, path, priority, recursive, relativePath, reprocess, requireFiles, to_filename, white_list, _changedTimes, _ref1, _ref2, _ref3, _ref4, _xp;

    if (options == null) {
      options = {};
    }
    white_list = options.white_list, black_list = options.black_list, destination = options.destination, compile = options.compile, to_filename = options.to_filename, relativePath = options.relativePath, callback = options.callback, filenamesOnly = options.filenamesOnly, priority = options.priority, freshen = options.freshen, reprocess = options.reprocess, binary = options.binary;
    if ((_ref1 = options.as_object) == null) {
      options.as_object = false;
    }
    if ((_ref2 = options.recursive) == null) {
      options.recursive = true;
    }
    if ((_ref3 = options.to_filename) == null) {
      options.to_filename = _to_filename;
    }
    if ((_ref4 = options.require) == null) {
      options.require = false;
    }
    as_object = options.as_object;
    recursive = options.recursive;
    path = options.path;
    on_change = options.on_change;
    destination = options.destination;
    compile = options.compile;
    callback = options.callback;
    to_filename = options.to_filename;
    requireFiles = options.require;
    args = arguments[0];
    if (relativePath == null) {
      relativePath = '';
    }
    _xp = {};
    if ('/' === _.last(path)) {
      path = path.slice(0, -1);
    }
    _changedTimes = {};
    _.each(fs.readdirSync(path), function(fileName) {
      var wholeProcess,
        _this = this;

      return (wholeProcess = function(again) {
        var addToObject, compiled, er, formatted_filename, fullPath, image_formats, loadedChildren, process, readFile, recompile, stats, trimmedFN, _changedFileName, _destDir, _fileTime, _ref5;

        if (black_list && _.include(black_list, fileName)) {
          return;
        }
        if (white_list && !_.include(white_list, fileName)) {
          return;
        }
        if (fileName.charAt(0) === '.') {
          return;
        }
        trimmedFN = trim_ext(fileName);
        fullPath = "" + path + "/" + fileName;
        _destDir = destination + '/' + (relativePath != null ? relativePath : '');
        stats = fs.lstatSync(fullPath);
        _fileTime = stats.ctime.getTime();
        if (_changedTimes[fullPath] === _fileTime) {
          console.log('returning');
          return;
        }
        _changedTimes[fullPath] = _fileTime;
        if (stats.isDirectory()) {
          if (destination) {
            try {
              fs.lstatSync(_destDir + '/' + fileName);
              if (again) {
                child.exec("rm -rf " + _destDir + fileName + "/*", function() {
                  return console.log.apply(console, ['DELETED'].concat(__slice.call(arguments)));
                });
              }
            } catch (_error) {
              er = _error;
              fs.mkdirSync(_destDir + '/' + fileName);
            }
          }
          fs.watch(fullPath, function() {
            return wholeProcess(true);
          });
          if (recursive) {
            loadedChildren = loadDir(_.extend(_.clone(args), {
              path: fullPath,
              white_list: false,
              relativePath: (relativePath != null ? relativePath : '') + fileName + '/'
            }));
            if (as_object) {
              _xp[trimmedFN] = _.extend((_ref5 = _xp[trimmedFN]) != null ? _ref5 : {}, loadedChildren);
            } else {
              _xp = _.extend(loadedChildren, _xp);
            }
          }
          return;
        }
        if (on_change || freshen || reprocess) {
          _.defer(function() {
            return fs.watch(fullPath, function() {
              return _.delay(function() {
                if (on_change === 'restart') {
                  loadDir.restartServer();
                }
                console.log('recompilin');
                if (reprocess) {
                  console.log('refreshen');
                  if (typeof readFile === "function") {
                    readFile();
                  }
                  if (typeof process === "function") {
                    process(true);
                  }
                }
                if (_.isFunction(on_change)) {
                  if (typeof on_change === "function") {
                    on_change({
                      readFile: readFile,
                      recompile: recompile,
                      addToObject: addToObject
                    });
                  }
                }
                if (freshen) {
                  console.log('refreshen');
                  if (typeof readFile === "function") {
                    readFile();
                  }
                  if (typeof recompile === "function") {
                    recompile();
                  }
                  return typeof addToObject === "function" ? addToObject() : void 0;
                }
              }, 250);
            });
          });
        }
        compiled = '';
        if (filenamesOnly) {
          return _xp[trimmedFN] = {};
        }
        image_formats = ['png', 'jpg', 'gif', 'jpeg'];
        if (binary == null) {
          binary = (_(image_formats)).include(extension(fullPath).toLowerCase()) ? 'binary' : void 0;
        }
        (readFile = function() {
          var contents, _ref6;

          contents = fs.readFileSync(fullPath, binary).toString();
          return compiled = (_ref6 = typeof compile === "function" ? compile(contents, fullPath) : void 0) != null ? _ref6 : contents;
        })();
        if (_.isFunction(callback)) {
          (process = function(reloaded) {
            return compiled = callback(_.extend(_.clone(args), {
              compiled: compiled,
              relativePath: relativePath,
              fileName: fileName,
              fullPath: fullPath,
              reloaded: reloaded
            }));
          })(false);
        }
        if (requireFiles) {
          try {
            require(fullPath);
          } catch (_error) {
            er = _error;
            _.defer(function() {
              return require(fullPath);
            });
          }
        }
        formatted_filename = to_filename(trimmedFN, extension(fileName));
        _changedFileName = _destDir + formatted_filename;
        if (destination != null) {
          (recompile = function() {
            return fs.writeFileSync(_changedFileName, compiled, binary);
          })();
        }
        return (addToObject = function() {
          if (as_object != null) {
            return _xp[(relativePath != null ? relativePath : '') + formatted_filename] = compiled;
          } else {
            return _xp[formatted_filename] = _.extend(compiled, _xp[formatted_filename]);
          }
        })();
      })(false);
    });
    return _xp;
  };

  loadDir.restartServer = function() {
    fs.writeFileSync('loadDir_tmp_restart.txt', Math.random());
    require('loadDir_tmp_restart.txt');
    return fs.writeFileSync('loadDir_tmp_restart.txt', Math.random());
  };

}).call(this);
